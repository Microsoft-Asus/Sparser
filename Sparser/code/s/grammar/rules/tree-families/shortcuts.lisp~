;;; -*- Mode:LISP; Syntax:Common-Lisp; Package:SPARSER -*-
;;; Copyright (c) 2009 BBNT Solutions LLC. All Rights Reserved
;;; $Id:$
;;;
;;;     File:  "shortcuts"
;;;   Module:  "grammar;rules:tree-families:"
;;;  version:  April 2009

;; Started 4/3/09. Modeled on [model;core:kinds:object]

(in-package :sparser)


;;--- NP patterns

(defun np-head (string-for-noun) ;; "trunk", "car", ...
  (unless (stringp string-for-noun)
    (error "Argument must be a string providing the base noun"))
  (let* ((name (intern (string-upcase string-for-noun)
		       (find-package :sparser)))
	 (form
	 `(define-category ,name
	    :instantiates :self
	    :specializes individual
	    :realization
	      (:tree-family NP-common-noun
	       :mapping ((np . individual)
			 ;(n-bar . individual)
			 (np-head . :self))
	       :common-noun ,string-for-noun))))
    (eval form)))


;;--- verb patterns

(defun svo (string-for-verb)
  (let* ((name (category-name-from-string-arg string-for-verb))
	 (form
	  `(define-category ,name
	    :instantiates :self ;; place for generalization
	    :specializes event
	    :binds ((subject . individual)
		    (object . individual))
	    :realization
	      (:tree-family transitive
	       :mapping ((s . event)
			 (vp . event)
			 (vg . :self)
			 (np/subject . individual)
			 (np/object . individual)
			 (agent . subject)
			 (patient . object))
	       :main-verb ,string-for-verb))))
    (eval form)))

(defun sv-prep-marked-o (verb preposition)
  (unless (and (stringp verb) (stringp preposition))
    (error "Arguments must be string giving the base for of words"))
  (let* ((name (category-name-from-string-arg 
		(string-append verb "-" preposition)))
	 (form
	 `(define-category ,name
	    :instantiates :self ;; place for generalization
	    :specializes event
	    :binds ((subject . individual)
		    (object . individual))
	    :realization
	      (:tree-family transitive/pp
	       :mapping ((s . :self)
			 (vp . :self)
			 (vg . :self)
			 (np/subject . individual)
			 (prep . ,preposition)
			 (pp/np . individual)
			 (agent . subject)
			 (theme . object))
	       :main-verb ,verb))))
    (eval form)))


;;--- go'fers
(defvar *sa* nil)
(defun category-name-from-string-arg (string-arg)
  ;; Could actually be a cons to cover irregulars
  (typecase string-arg
    (string
     (intern (string-upcase string-arg)
	     (find-package :sparser)))
    (cons
     ;;/// a good place to check for valid keywords for the irregulars
     (unless (stringp (car string-arg))
       (error "Arguments must be string giving the base for of words"))
     (do ((keyword (first (cdr string-arg)) (car rest))
	  (string (second (cdr string-arg)) (cadr rest))
	  (rest (cdddr string-arg) (cddr rest)))
	 ((null keyword))
       ;(break "keyword = ~a  string = ~a" keyword string)
       (unless (keywordp keyword)
	 (error "Looks like a badly formed irregulars list:~%~a" string-arg))
       (unless (memq keyword *valid-keywords-for-irregular-word-forms*)
	 (error "Keyword for marking an irregular form, ~a, isn't one ~
                  of these:~%  ~a" keyword
		  *valid-keywords-for-irregular-word-forms*))
       (unless (stringp string)
	 (error "Words have to be given as strings. ~a isn't:~%~a"
		string string-arg)))       
     (let ((base (car string-arg)))
       (intern (string-upcase base)
	       (find-package :sparser))))))


