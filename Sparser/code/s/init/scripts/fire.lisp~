;;; -*- Mode:LISP; Syntax:Common-Lisp; Package:(CL-USER COMMON-LISP) -*-
;;; Copyright (c) 2007 BBNT Solutions LLC. All Rights Reserved
;;; $Id:$
;;;
;;;      File:   "fire"
;;;    Module:   "init;scripts:"
;;;   version:   June 2007

;; Adapted from 'just dm&p' 6/20/07

(in-package :cl-user)

#|  ----- This file is intended to be loaded first. ----- |#

;;;---------------------------
;;; Platform-specific globals
;;;---------------------------

;;; Specialize this global to the equivalent place on your machine
;;; If running in a unix-based lisp such as Allegro (i.e. one that
;;; sets the  #+unix feature in *features*), this global can be
;;; removed because the code in everything.lisp will calculate its
;;; file location automatically.
;;;   If you don't set it, then provide a hard pathname in the
;;; call to load at the bottom on this file.

(unless (boundp 'location-of-Sparser-directory)
  (defparameter location-of-Sparser-directory
    #+apple "G4:Users:ddm:nlp:Sparser:"
    #+allegro "/Users/ddm/ws/nlp/Sparser/"
    ))


;;;--------------------
;;; define the package
;;;--------------------

(or (find-package :sparser)
    (make-package :sparser
                  :use #+:apple '(ccl common-lisp)
                       #+:unix  '(common-lisp)
                       ))


;;;-------------------------------------------------
;;; setup the parameters -- specialize the defaults
;;;-------------------------------------------------

(defparameter sparser::*fire* t
  "Turn on the flag that controls which grammar modules are 
   loaded and other governs other parameterized settings")

(defparameter sparser::*load-ad-hoc-rules* t)

(defparameter sparser::*no-image* t)

#+allegro (defparameter sparser::*binaries-directory-name* "s")


(when t ;; CTAM
  (unless (member :allegro *features*)
    (break "Not running under Allegro Common Lisp. ~
            Can't construct relative pathname to location of Sparser"))
  (defparameter *location-of-ctam-grammar*
    (namestring
     (merge-pathnames
      (make-pathname :directory `(:relative
				  :up ;; scripts
				  :up ;; init
				  :up ;; s
				  :up ;; code
				  :up ;; Sparser
				  "Fire"
				  "CTAM-grammar"))
      (make-pathname :directory (pathname-directory *load-truename*)))))
  ;;(break "CTAM is at ~%~a" *location-of-ctam-grammar*)

  (defparameter sparser::*external-grammar-files* 
    (concatenate 'string *location-of-ctam-grammar* "loader.lisp"))

  (defparameter sparser::*new-dm&p* t) ;; see globals

  ) ;; CTAM


;;;-----------------
;;; call the loader
;;;-----------------

(load (concatenate 'string 
        location-of-Sparser-directory
	#+apple "code:s:init:everything"
	#+unix  "code/s/init/everything.lisp"
	))

(in-package :sparser)

;; These flags aren't guarded by a 'unless boundp'
;; When we get a reasonably full set we'll package it
;; as a 
(setq *treat-single-Capitalized-words-as-names* t)

(setq *annotate-realizations* nil)
 ;; This is part of the long-term project to record the style of
 ;; a test as a side effect of noticing what rules were used
 ;; when it was being parsed. Crucial for effective generation
 ;; but it presupposed that -all- rules are created by realization
 ;; schema, so it won't work when there are ad-hoc rules in the
 ;; mix. 

