;;; -*- Mode:LISP; Syntax:Common-Lisp; Package:(SPARSER) -*-
;;; Copyright (c) 2007-2009 BBNT Solutions LLC. All Rights Reserved
;;; $Id:$

;;;     File:  "export"
;;;   Module:  drivers;sinks:
;;;  version:  April 2009

;; Initiated 2/26/07
;; 3/2 Added switch to make it accumulate and wait until called for.
;; 4/27/09 Moved in to main distribution. Extended for Checkpoint Ops,

(in-package :sparser)

;;;---------
;;; globals
;;;---------

(unless (boundp '*batch-salient-object-export*)
  (defparameter *batch-salient-object-export* t
    "If true, export is delayed until a call is made to 
    'export-all-salient-objects'. Otherwise the exports
    are done incrementally at the time that the treetop
    that has the salient object as its referent is handled."))

(unless (boundp '*export-in-demo-mode*)
  (defparameter *export-in-demo-mode* nil
    "When this is off, we just export the string that carries
     the pseudo-tuple information. When it's on, we're showing
     it to people who want to see more. Read in export-object."))

(unless (boundp '*export-as-return-value*)
  (defparameter *export-as-return-value* t
    "Read in export-tuple, -psi, and -individual and controls whether
     we form an sexp to be returned or print to the export-stream."))


(defvar *export-stream* *standard-output*)


(defvar *pending-salient-objects* nil
  "Holds the batch of objects. Initialized at the start
   of a run.")

(define-per-run-init-form 
    '(setq *pending-salient-objects* nil))


;;;--------------
;;; batch driver
;;;--------------

(defun export-salient-objects ()
  (if *pending-salient-objects*
    (with-output-to-string (s)
      (let ((*export-stream* s))
	(declare (special *export-stream*))
	(dolist (item *pending-salient-objects*)
	  (let ((obj (first item))
		(string (second item)))
	    (export-object-toplevel obj string)
	    (terpri s)))) ;; blank line
      s)))


;;;------------------------------
;;; incremental driver and cases
;;;------------------------------

;; This is called as a 'generic-treetop-action'
;; see Do-generic-actions-off-treetop

(defun export-bindings/recursively (edge)
  (tr :exporting-referent edge)
  (let ((referent (edge-referent edge))
	(wording (string-of-words-between
		  (pos-edge-starts-at edge)
		  (pos-edge-ends-at edge))))
    (if (null referent)
      (tr :no-referent-to-export)
      (if *batch-salient-object-export*
	(push `(,referent ,wording)
	      *pending-salient-objects*)
	(export-object-toplevel referent wording)))))


;;;----------------------------------
;;; the code that does the exporting
;;;----------------------------------

(defun export-object-toplevel (obj wording-string)
  (tr :exporting obj)
  (when *export-in-demo-mode*
    (format *export-stream* 
	    "~&~%Recovered these tuples from this text passage:~
               ~%            \"~a\"~%" 
	    wording-string))
  (export-object obj))

(defun export-object (obj)
  (cond
    ((export-function (category-of obj))
     (use-export-specialist obj))
    ((and *export-as-return-value*
	  (primitive-for-export obj))
     obj)
    (t
     (typecase obj
       (psi
	(export-psi obj))
       (individual
	(export-individual obj))
       (otherwise
       (break "Export -- unexpected type of object: ~a~%~a"
	      (type-of obj) obj))))))


(defun export-psi (psi)
  (let ((v+v (psi-v+v psi)))
    (if *export-as-return-value*
      (export-psi-as-return-value psi v+v)
      (let ((object-name (export-name-for psi)))
	(dolist (vv v+v)
	  (export-v+v object-name vv))))))

(defun export-v+v (name v+v)
  (let ((variable (vv-variable v+v))
	(value (vv-value v+v)))
    (let ((var-name (var-name variable))
	  (name-for-value (if (null value) ;; 3/9 guts of embedded markup
			    "null"
			    (export-name-for value))))
      (export-tuple name
		    var-name 
		    name-for-value)
      (when (and value
		 (not (primitive-for-export value)))
	(export-object value)))))


(defun export-individual (i)
  (let ((bindings (indiv-binds i)))
    (if *export-as-return-value*
      (export-individual-as-return-value i bindings)
      (dolist (b bindings)
	(export-binding b)))))

(defun export-binding (b)
  (let* ((variable (binding-variable b))
	 (value (binding-value b))
	 (i (binding-body b)))
    (let ((name-for-individual (export-name-for i))
	  (var-name (var-name variable))
	  (value-name (or (primitive-for-export value)
			  (export-name-for value))))
      (export-tuple name-for-individual
		    var-name
		    value-name)
      (when (not (primitive-for-export value))
	(export-object value)))))

;;--- return-value versions

(defun export-psi-as-return-value (psi v+v)
  `(,(export-as-value-name-for psi)
     ,@(mapcar #'export-v+v-as-return-value v+v)))

(defun export-v+v-as-return-value (v+v)
  (let ((variable (vv-variable v+v))
	(value (vv-value v+v)))
    `(,(export-as-value-name-for variable)
       ,@(export-object value))))
  
  
(defun export-individual-as-return-value (i bindings)
  `(,(export-as-value-name-for i)
     ,@(mapcar #'export-binding-as-return-value bindings)))

(defun export-binding-as-return-value (b)
  (let ((variable (binding-variable b))
	(value (binding-value b)))
    `(,(export-as-value-name-for variable) 
       ,@(export-object value))))


;;--- common final path for bindings and V+V

(defun export-tuple (name-for-individual
		     name-for-variable
		     name-for-value)
  (if *export-as-return-value*
    `(,name-for-variable ,name-for-value)
    (format *export-stream* "~&     [~a, ~a, ~a]~%"
	    name-for-individual
	    name-for-variable
	    name-for-value)))


;;;---------
;;; go-fers
;;;---------

(defun export-as-value-name-for (obj)
  (typecase obj
    (psi
     (let ((category (category-lattice-node-belongs-to 
		      (psi-lattice-point obj))))
       (export-name-as-category category)))
    (individual
     (let ((category (car (indiv-type obj))))
       (export-name-as-category category)))
    (lambda-variable
     (var-name obj))
    (otherwise
     (break "Unexpected type: ~a~%~a"
	    (type-of obj) obj))))


(defun export-name-for (obj)
  (typecase obj
    (psi
     (let ((category (category-lattice-node-belongs-to 
		      (psi-lattice-point obj)))
	   (id (psi-id obj)))
       (name-as-category-and-id category id)))
    (individual
     (let ((category (car (indiv-type obj)))
	   (id (indiv-id obj)))
       (name-as-category-and-id category id)))
    (symbol obj)
    (otherwise
     (break "Unexpected type: ~a~%~a"
	    (type-of obj) obj))))


(defun export-name-as-category (category)
  (intern (symbol-name (cat-symbol category))
	  (find-package :sparser)))

(defun name-as-category-and-id (category id)
  (intern (string-append (symbol-name (cat-symbol category))
			 "-" (format nil "~a" id))
	  (find-package :sparser)))


(defun primitive-for-export (obj)
  (typecase obj
    (number obj)
    (symbol obj)
    (string obj)
    (word (word-pname obj))
    ((or psi
	 individual)
     nil)
    (otherwise
     (break "Is this a primitive when exporting? ~a~%~a"
	    (type-of obj) obj))))


;;;----------------------------------------
;;; an escape to allow type-specific cases
;;;----------------------------------------

(defparameter *categories-to-export-functions* (make-hash-table))

(defun define-export-routine (category name-of-function)
  (setf (gethash category *categories-to-export-functions*)
	name-of-function))

(defun export-function (category)
  (gethash category *categories-to-export-functions*))
  
(defun use-export-specialist (obj)
  (let ((fn (export-function (category-of obj))))
    (unless fn
      (break "Expected ~a to have an export specialist" obj))
    (funcall fn obj)))


;;;--------
;;; traces
;;;--------

(defparameter *trace-bindings-export* nil)

(defun trace-export ()
  (setq *trace-bindings-export* t))

(defun untrace-export ()
  (setq *trace-bindings-export* nil))

(deftrace :exporting-referent (edge)
  (when *trace-bindings-export*
    (trace-msg "Exporting the referent of ~a" edge)))

(deftrace :exporting (obj)
  (when *trace-bindings-export*
    (trace-msg "Exporting the referent of ~a" obj)))

(deftrace :no-referent-to-export ()
  (when *trace-bindings-export*
    (trace-msg "  But the edge has no referent!")))


