
6/7/08

"many of the ..."

How do we tell if "many" is defined already?

SPARSER> (p "many")
many

                                 SOURCE-START
e0                               "many"
                                 END-OF-SOURCE
:DONE-PRINTING
SPARSER> (d (e# 0))
#<edge0 1 "many" 2> is a structure of type EDGE.  It has these slots:
 CATEGORY           #<word "many">
 FORM               #<ref-category QUANTIFIER>
 REFERENT           #<word "many">
 STARTS-AT          #<edges starting at 1>
 ENDS-AT            #<edges ending at 2>
 RULE               ((6) NIL . 40960)
 LEFT-DAUGHTER      #<word "many">
 RIGHT-DAUGHTER     :LITERAL-IN-A-RULE
 USED-IN            NIL
 POSITION-IN-RESOURCE-ARRAY  0
 CONSTITUENTS       NIL
 SPANNED-WORDS      NIL
#<edge0 1 "many" 2>

SPARSER> (d (word-named "many"))
#<word "many"> is a structure of type WORD.  It has these slots:
 PLIST
    (:FUNCTION-WORD #<ref-category QUANTIFIER> :GRAMMAR-MODULE
     #<grammar-module *QUANTIFIERS*> :FILE-LOCATION
     "/Users/ddm/ws/nlp/Sparser/code/s/grammar/rules/words/quantifiers1.fasl")
 SYMBOL             WORD::|many|
 RULE-SET           #<rule-set for #<word "many">>
 PNAME              "many"
 MORPHOLOGY         NIL
 CAPITALIZATION     :LOWER-CASE
 CAPITALIZATION-VARIANTS  NIL
#<word "many">
SPARSER> 

SPARSER> (d (rule-set-for *))
#<rule-set for #<word "many">> is a structure of type RULE-SET.  It has
these slots:
 BACKPOINTER        #<word "many">
 SINGLE-TERM-REWRITES  NIL
 RIGHT-LOOKING-IDS  (NIL . 40960)
 LEFT-LOOKING-IDS   (6)
 FSA                NIL
 PHRASE-BOUNDARY    #<brackets for #<word "many">>
 COMPLETION-ACTIONS  NIL
 PLIST              NIL
#<rule-set for #<word "many">>

SPARSER> (d (rs-phrase-boundary *))
#<brackets for #<word "many">> is a structure of type
BRACKET-ASSIGNMENT.  It has these slots:
 ENDS-BEFORE        #<bracket ].PHRASE >
 BEGINS-BEFORE      #<bracket .[NP >
 ENDS-AFTER         NIL
 BEGINS-AFTER       NIL
 BACKPOINTER        #<word "many">
#<brackets for #<word "many">>


;;;------------------------------------------------------------
;; Finding the data for setting up a form rule to roll this up

(p "were reported on Monday, August 29, 2005")
were reported on Monday, August 29, 2005

                                 SOURCE-START
e2    REPORT-VERB             1 "were reported" 3
e17   TIME                    3 "on monday , august 29 , 2005" 10
                                 END-OF-SOURCE
SPARSER> (d (e# 2))
#<edge2 1 report-verb 3> is a structure of type EDGE.  It has these
slots:
 CATEGORY           #<ref-category REPORT-VERB>
 FORM               #<ref-category VERB+PASSIVE>
 REFERENT           #<report-verb "report" 2>
 STARTS-AT          #<edges starting at 1>
 ENDS-AT            #<edges ending at 3>
 RULE               #<PSR105  {verb+ed} -> be verb+ed>
 LEFT-DAUGHTER      #<edge0 1 be 2>
 RIGHT-DAUGHTER     #<edge1 2 report-verb 3>
 USED-IN            NIL
 POSITION-IN-RESOURCE-ARRAY  2
 CONSTITUENTS       NIL
 SPANNED-WORDS      NIL

; This tells us that we need to raise the type of the VG up to Event
; so that we have a suite of generic properties to bind the time
; (and location, modality, ...)

; Time is the concrete class, so the form has to come from the VG
; The fact that this is labeled verb+passive rather than just verb
; will multiply the number of rules we need to write, so some though
; should go into how to couch this. Perhaps a function that provides
; a wrapper to abstract this away is to the point -- question is
; where to stash it. Presumably late in the syntax of verbs.


;;----------------------------------------------------------------
SPARSER> (d (category-named 'sequencer))
#<ref-category SEQUENCER> is a structure of type REFERENTIAL-CATEGORY.
It has these slots:
 PLIST
    (:1ST-PERMANENT-INDIVIDUAL #<sequencer "during" 6>
     :PERMANENT-INDIVIDUALS
     (#<sequencer "during" 6> #<sequencer "before" 5>
      #<sequencer "after" 4> #<sequencer "subsequent" 3>
      #<sequencer "next" 2> #<sequencer "last" 1>)
     :1ST-PERMANENT-INDIVIDUAL #<sequencer "during" 6>
     :PERMANENT-INDIVIDUALS
     (#<sequencer "during" 6> #<sequencer "before" 5>
      #<sequencer "after" 4> #<sequencer "subsequent" 3>
      #<sequencer "next" 2> #<sequencer "last" 1>)
     :1ST-PERMANENT-INDIVIDUAL #<sequencer "during" 6>
     :PERMANENT-INDIVIDUALS
     (#<sequencer "during" 6> #<sequencer "before" 5>
      #<sequencer "after" 4> #<sequencer "subsequent" 3>
      #<sequencer "next" 2> #<sequencer "last" 1>)
     :INSTANCES
     (#<sequencer "during" 6> #<sequencer "before" 5>
      #<sequencer "after" 4> #<sequencer "subsequent" 3>
      #<sequencer "next" 2> #<sequencer "last" 1>)
     :COUNT 6 :INSTANCES-ARE-PERMANENT T :GRAMMAR-MODULE
     #<grammar-module *SEQUENCERS*> :FILE-LOCATION
     "/Users/ddm/ws/nlp/Sparser/code/s/grammar/model/core/adjuncts/sequence/object.fasl")
 SYMBOL             CATEGORY::SEQUENCER
 RULE-SET           #<rule-set for #<ref-category SEQUENCER>>
 SLOTS              (#<variable NAME :: PRIMITIVE WORD>)
 BINDS              NIL
 REALIZATION
    (:SCHEMA ((:WORD . #<variable NAME :: PRIMITIVE WORD>) NIL NIL NIL)
     :RULES NIL)
 LATTICE-POSITION   #<top-lp of sequencer  50>
 OPERATIONS         #<operations for sequencer>
 MIX-INS            NIL
 INSTANCES          #<EQL hash-table with 6 entries @ #x10a4970a>
 RNODES             NIL

;;-----------------------------------------------------------
SPARSER> (p "next week")
next week

                                 SOURCE-START
e2    TIME                    1 "next week" 3
                                 END-OF-SOURCE
:DONE-PRINTING
SPARSER> (d (e# 2))
#<edge2 1 time 3> is a structure of type EDGE.  It has these slots:
 CATEGORY           #<ref-category TIME>
 FORM               #<ref-category NP>
 REFERENT           #<psi relative-time 33>
 STARTS-AT          #<edges starting at 1>
 ENDS-AT            #<edges ending at 3>
 RULE               #<PSR315  time ->  sequencer time-unit>
 LEFT-DAUGHTER      #<edge0 1 sequencer 2>
 RIGHT-DAUGHTER     #<edge1 2 time-unit 3>
 USED-IN            NIL
 POSITION-IN-RESOURCE-ARRAY  2
 CONSTITUENTS       NIL
 SPANNED-WORDS      NIL
#<edge2 1 time 3>
SPARSER> (d (psr# 315))
#<PSR315  time ->  sequencer time-unit> is a structure of type CFR.  It
has these slots:
 SYMBOL             RULE::PSR315
 CATEGORY           #<ref-category TIME>
 RHS
    (#<ref-category SEQUENCER> #<ref-category TIME-UNIT>)
 COMPLETION         NIL
 FORM               #<ref-category NP>
 RELATION           NIL
 REFERENT
    (:INSTANTIATE-INDIVIDUAL-WITH-BINDING #<ref-category RELATIVE-TIME>
     (#<variable RELATIVIZER :: relative-time-adverb> . LEFT-REFERENT)
     (#<variable REFERENCE-TIME :: time> . RIGHT-REFERENT))
 SCHEMA             #<schr NP -> MODIFIER NP-HEAD >
 PLIST
    (:RELATION :DEFINITE-MODIFIER :GRAMMAR-MODULE
     #<grammar-module *TIME*> :FILE-LOCATION
     "/Users/ddm/ws/nlp/Sparser/code/s/grammar/model/core/time/relative-moments.fasl")
#<PSR315  time ->  sequencer time-unit>


;;-----------------------------------------------------------------------
SPARSER> (p "A breach in the Industrial Canal, ")
A breach in the Industrial Canal, 

                                 SOURCE-START
e2    BREACH                  1 "a breach" 3
e11   IN-LOCATION             3 "in the industrial canal" 7
e10                              "COMMA"
                                 END-OF-SOURCE
:DONE-PRINTING
SPARSER> (tree 11)
E11 IN-LOCATION               p3 - p7   rule 218
  E3 "in"                     p3 - p4   (348160)
    "in"
  E9 NAME                     p4 - p7   sdm-span-segment
    E5 "the"                  p4 - p5   (335872 . 315392)
      "the"
#<edge11 3 in-location 7>
;; //// Where is the wacko label coming from on e5 -- it's pulling out the
;; wrong field.


;;---------------------------------------------------------------
7/14/08
;; debug the issue in pnf, which is off the wall
(p "An Iraqi girl died on Jan. 17.")

(trace-network)
(trace-brackets)
(trace-pnf)

8/9/08
SPARSER> (p "An girl died on Jan. 17.")
An girl died on Jan. 17.

                                 SOURCE-START
e0                               "an"
e13   DIE                     2 "girl died on jan . 17" 8
e11                              "PERIOD"

Why is "An" not combining with "girl" ??  Because there isn't a rule
for it. "girl" is spanned by [person, common-noun]. The easiest thing
would be a form-form rule if we could sanction it (only have to state
it once, vs for every sort of common noun. The 'girl' rule is in
/model/core/people/kinds.lisp:

(define-category  girl
  :instantiates person
  :specializes person
  ;;/// How do we index this sort of thing?
  :realization (:common-noun "girl"))

;; 8/28/08

SPARSER> (p "19:00:00")
19:00:00

;; This looks like a real bug in how the data structures are assembled
;; in this instance that I've seen hints about before. 

 0: (SWANK::DEBUG-IN-EMACS #<SIMPLE-ERROR @ #x10e0dbfa>)
  1: (SWANK:SWANK-DEBUGGER-HOOK #<SIMPLE-ERROR @ #x10e0dbfa> #<Function SWANK-DEBUGGER-HOOK>)
  2: (ERROR "No generic access function for rule-sets defined ~
                 ~%  for objects of type ~A" SYMBOL)
  3: (RULE-SET-FOR :DOTTED-INTERMEDIARY)
  4: (LET ((RS (RULE-SET-FOR LABEL))) (WHEN RS (CASE DIRECTION (:RIGHT-LOOKING #) (:LEFT-LOOKING #) (OTHERWISE #))))
  5: (LET ((LABEL (IF # EDGE #))) (WHEN LABEL (LET (#) (WHEN RS #))))
  6: (CATEGORY-IDS #<edge10 1 number_: 3> :RIGHT-LOOKING :FORM)
  7: (FORM-IDS/RIGHTWARD #<edge10 1 number_: 3>)
  8: (LET* ((LEFT-CATEGORY-IDS (CATEGORY-IDS/RIGHTWARD LEFT-EDGE)) (LEFT-FORM-IDS (FORM-IDS/RIGHTWARD LEFT-EDGE)) (RIGHT-CATEGORY-IDS (CATEGORY-IDS/LEFTWARD RIGHT-EDGE)) (RIGHT-FORM-IDS (FORM-IDS/LEFTWARD RIGHT-EDGE))) (IF (OR LEFT-FORM-IDS RIGHT-FORM-IDS) (THEN (TR :CHECKING-FORM-LABEL-CATEGORY-RULES) (OR # # #)) (ELSE (TR :NEITHER-HAS-CATEGORY-ON-FORM-IDS) (MULT/CHECK-FORM-OPTIONS LEFT-EDGE RIGHT-EDGE))))
  9: (MULT/IDS-ON-FORM-LABEL #<edge10 1 number_: 3> #<edge9 3 numeric-time 6>)
 10: (MULTIPLY-CATEGORIES (675840) NIL #<edge10 1 number_: 3> #<edge9 3 numeric-time 6>)
 11: (OR (MULTIPLY-CATEGORIES LEFT-CATEGORY-IDS RIGHT-CATEGORY-IDS LEFT-EDGE RIGHT-EDGE) (WHEN *EDGES-FROM-REFERENT-CATEGORIES* (MULTIPLY-REFERENTS LEFT-EDGE RIGHT-EDGE)))
 12: (LET ((LEFT-CATEGORY-IDS (CATEGORY-IDS/RIGHTWARD LEFT-EDGE)) (RIGHT-CATEGORY-IDS (CATEGORY-IDS/LEFTWARD RIGHT-EDGE))) (OR (MULTIPLY-CATEGORIES LEFT-CATEGORY-IDS RIGHT-CATEGORY-IDS LEFT-EDGE RIGHT-EDGE) (WHEN *EDGES-FROM-REFERENT-CATEGORIES* (MULTIPLY-REFERENTS LEFT-EDGE RIGHT-EDGE))))
 13: (MULTIPLY-EDGES #<edge10 1 number_: 3> #<edge9 3 numeric-time 6>)
 14: (CHECK-ONE-ONE #<edge10 1 number_: 3> #<edge9 3 numeric-time 6>)
 15: (CHECK-FOR-RIGHT-EXTENSIONS/FOREST #<edge10 1 number_: 3>)
 16: (SETUP-RETURNS-FROM-PPTT-&-RUN #<edge9 3 numeric-time 6> #<position6 6 "">)
 17: (END-OF-SOURCE-CHECK #<word END-OF-SOURCE> #<position6 6 "">)
 18: (CHECK-FOR-[-FROM-WORD-AFTER #<word END-OF-SOURCE> #<position6 6 "">)
 19: (SCAN-NEXT-SEGMENT #<position6 6 "">)

;; Turns out to be a due to unanticipated fanout from a change last
;; year to allow a low-level routine in the rule lookup to look at
;; the form levels on an edge rather than just the category label,
;; but I hadn't appreciated/remembered that on dotted rules (expansions
;; of n-ary rules) the form label on the intermediaries is a symbol
;; and therefore should be ignored.





